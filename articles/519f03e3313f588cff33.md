---
title: "全文検索だけElasticsearchに移行した際のはまり所"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['elasticsearch']
published: false
---
SQLの全文検索がなかなかパフォーマンス的にきつくなってきて、全文検索部分だけElasticsearchに移行する機会があったのでその際の実装周りの個人的なはまり所と対応をまとめました。
多分Elasticsearch全然使ったことない人向けです。

# Elasticsearchとの付き合い方

## とりあえずkibana

ESに慣れてない状態でいきなり実装から入るとどこがおかしいかわかりにくいので、しばらくはkibana経由でいじるようにするといいです。公式ドキュメントに色々説明は書いてありますが、実際に動かして検索結果を見た方が色々理解がはかどります。
また、kibanaのdev toolはサジェストが優秀なのでさくさくクエリが書けます。検索実装前にkibanaでクエリの完成形を決めてしまったほうが実装が進めやすいです。

## 検索しやすさ重視でデータ構造を考える

ESを検索インデックスとしてだけ使うのであれば、ESに格納するのは検索やソート、集計に使う最低限のフィールドだけ追加すれば十分です。また、フィールドの追加は容易に行えるので、データベースとにらめっこして設計するよりも、最低限でデータ流し込み→kibanaで検索やソートをしてみる→フィールドが欲しくなったら足して再度データ流し込み...というループを繰り返しながら設計を作りこんでいくのがおすすめです。

## 基本updateしない
updateメソッドがありますが、基本使う必要はありません。データを更新したい場合は、主キーの_idが同じindexをそのまま追加します。_idがすでにあれば更新、なければ新規、と勝手に判断されます。同じ_idのものが二個あって検索に両方引っかかったりするようなことは起こりません。古くなったものは定期的にお掃除されて消えていきます。

## bulkに投げてる謎のsyntaxはjsonl
bulkでは複数の処理をまとめて投げられますが、Bulk APIの公式ドキュメントをみるとjsonが縦に並んだ謎の書き方が書かれてます。これはサンプルをいっぱい並べてある、というわけではなく、jsonlというデータ構造なようです。なぜかjsonの配列ではなくjsonl形式で各々の処理を投げることを求められているので、適宜jsonlを使えるライブラリを入れるなり作るなりしておきましょう。

# nestedの回避
ESでは1:Nデータを格納する方法としてnestedというものが用意されていますが、インデックスの性質上安易に使うとパフォーマンスが低下します。
要件によってはどうしてもnestedを使わざるを得ないケースもありますが、検索インデックスとしてだけESを使う（=別途SQLでデータの整合性を担保している）のであれば回避できるケースが多いです。いくつか回避できた具体例を挙げてみます。

## Nが有限に分類可能な場合
ユーザーごとのオプション設定として下記のようなデータ構造があるとします。
このようなケースでは各オプション設定に固有の名前をフィールド名としてESに格納すればnestedを使わなくとも検索やソートの対象にすることが可能です。

## nestされた要素の対象を特定した状態で検索できる場合
例えば記事ごとに担当者が複数設定されているようなデータ構造を考えます。
この場合、ESには担当ユーザーのIDだけ配列で持たせておいて、フロントではサジェストやセレクトボックス利用する、先に担当者テーブルを検索して対象となるIDを取得しておく、などして検索クエリに担当者のIDだけを投げることで担当者での絞り込み検索を行うことが可能です。

# 検索クエリ
## SQLでやってた普通な絞り込みは大体Boolean Queryで置き換えられる
elasticseachのドキュメントを見ると山ほど検索クエリの種類があって面をくらいますが、SQLでwhere and and ...とかやってたやつは、bool>mustで置き換え可能です。

## 曖昧でない部分一致はmatch_phraseかquery_string
ESのドキュメントによく出てくるmatch検索はあいまい検索です。SQLでlike検索やngram のboolean modeで検索していた機能をそのまま踏襲したい場合はmatch_phraseやquery_stringを使います。
似たものとしてwildcard queryもありますが、これは前方一致や後方一致に使うもので、全文検索インデックスを使わないので長文に対して使うにはパフォーマンスが良くないようです。

## 絞り込みが無くなるときはmatch_allを置く
クエリによっては絞り込みが全くなくなる時があります。こういう時にESに投げるクエリの構造が大きく変わってしまうとコード上のハンドリングが面倒になるので、何も絞り込みが無くなるのであればmatch_allでの絞り込みを差し込んでおくことでクエリの構造を変えずに等価な検索ができます。
特に集計時のfilterなどはあるかないかでレスポンスの方まで変わってしまうのでmatch_allの利用がおすすめです。


# 集計クエリ
## 1万件を超える結果を出したいならtrack_total_hits
デフォルトでは集計時に対象が1万件に絞られています。要件的にしっかり1万件以上の数字も出さなければならない場合はtrack_total_hitsをtrueにします。

## 項目の種類ごとの数を数えるならtextでなくkeywordやenumなどで格納しておく
例えば犬のデータベースを作り、犬の毛色ごとに何匹登録されているか表示する場合を考えます。
この場合Terms Aggregationを使うことで、フィールドが指定した要素を持つものの数を集計してくれますが、これをtextに対して行うとパフォーマンスが非常に悪いため、デフォルトでは無効化されています。毛色の情報を文字列でなくkeywordやenumでデータを格納しておく必要があります。

## 複数の集約で異なる絞り込みを行いたい場合はfilterとpost_filter
上記のケースで、今度は犬の毛色、犬種、雌雄などそれぞれ何匹いるか集計する場合を考えます。ここで例えば毛色をルビーで絞り込んだ場合、犬種や雌雄はルビーの中だけで検索すればいいですが、毛色の数は毛色での絞り込みを外して集計する必要があります。
この場合毛色での絞り込みはQueryにいれず、犬種と雌雄のaggregationにfilterとして挿入、最後にpost_filterで全体に適用、というようにすることで、集約ごとに異なるfilterをかけることができます。
この際、aggsにfilterがあったりなかったりすると帰ってくるレスポンスの階層が変わるため、前述のmatch_allを使ってすべてのaggsにfilterをつけるようにしておくのがおすすめです。

# ユニットテスト
## データを格納してすぐ検索でアサートする場合はrefresh=wait_for
indexにデータを追加するリクエストですが、デフォルトではインデックスの更新が終わる前にレスポンスが返ってきます。ユニットテストなどでデータを追加した直後に検索するようなテストを行うと、インデックス更新前に検索してしまってデータがはいっていない、といったことが起こります。こういった場合はrefresh=wait_forを指定することで、インデックスの更新を待ってレスポンスが返ってくるようになります。
うちの環境ではrefreshの指定をenvに書いてしまって、ユニットテスト環境だけwait_forにするようにしました。